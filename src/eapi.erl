%%% File    : eapi.erl
%%% Author  : Tony Rogvall <tony@rogvall.se>
%%% Description : Erlang driver API generator
%%% Created : 18 Mar 2010 by Tony Rogvall <tony@rogvall.se>

-module(eapi).

-import(lists, [map/2, foreach/2, reverse/1, foldl/3]).


-export([verify_file/1, 
	 verify_value/3]).

-export([erlang/2, c/2]).
-export([is_integer_type/2, is_pointer_type/2]).

-compile(export_all).

-include("eapi.hrl").


%%
%% Input file is name.api
%% OutFile is <base>
%%          => <base>.erl
%%          => <base>.hrl
%%
erlang(InFile, OutFile) ->
    case load(InFile, OutFile) of
	{ok,Api} ->
	    %% Generate erlang code
	    {Hrl_defs,Erl_code} = eapi_erl:code(Api),
	    %% Write code
	    {ok,Fd1} = file:open(OutFile++".erl", [write]),
	    io:format(Fd1, "%% Generated by eapi (DO NOT EDIT)\n",[]),
	    io:format(Fd1, "-module(~s).\n\n", [Api#api.name]),
	    io:format(Fd1, "-export([start_link/0, start/0, stop/0]).\n",[]),
	    io:format(Fd1, "-export([start_link/1, start/1]).\n",[]),
	    dict:fold(
	      fun(_ID,F,_) ->
		      io:format(Fd1, "-export([~s/~w]).\n",
				[F#api_function.name,
				 length(F#api_function.args)])
	      end, ok, Api#api.functions),
	    io:format(Fd1, "-include_lib(\"eapi/include/cbuf.hrl\").\n", []),
	    lists:foreach(
	      fun(Include) ->
		      io:format(Fd1, "-include(~s).\n", [Include])
	      end, Api#api.erl_includes),
	    io:format(Fd1, "-include(\"~s.hrl\").\n\n", [Api#api.name]),
	    %% output standard functions
	    output_start_link(Fd1,Api),
	    output_start(Fd1,Api),
	    output_stop(Fd1,Api),
	    put_chars(Fd1, Erl_code),
	    file:close(Fd1),


	    %% Write definitions
	    {ok,Fd2} = file:open(OutFile++".hrl", [write]),
	    io:format(Fd2, "%% Generated by eapi (DO NOT EDIT)\n",[]),
	    io:format(Fd2, "-ifndef(__~s_HRL__).\n", [Api#api.uname]),
	    io:format(Fd2, "-define(__~s_HRL__,true).\n", [Api#api.uname]),
	    put_chars(Fd2, Hrl_defs),
	    io:format(Fd2, "-endif.\n", []),
	    file:close(Fd2),
	    ok;
	error ->
	    error
    end.


c(InFile, OutFile) ->
    case load(InFile, OutFile) of
	{ok,Api} ->
	    %% Generate erlang code
	    {H_defs,C_code} = eapi_c:code(Api),

	    %% Write code 
	    {ok,Fd1} = file:open(OutFile++".c", [write]),
	    io:format(Fd1, "// Generated by eapi (DO NOT EDIT)\n",[]),
	    io:format(Fd1, "#include \"eapi_drv.h\"\n", []),
	    lists:foreach(
	      fun(Include) ->
		      io:format(Fd1, "#include ~s\n", [Include])
	      end, Api#api.c_includes),
	    io:format(Fd1, "#include \"~s.h\"\n\n", [Api#api.name]),
	    put_chars(Fd1, C_code),
	    file:close(Fd1),

	    %% Write definitions
	    {ok,Fd2} = file:open(OutFile++".h", [write]),
	    io:format(Fd2, "// Generated by eapi (DO NOT EDIT)\n",[]),
	    io:format(Fd2, "#ifndef __~s_H__\n", [Api#api.uname]),
	    io:format(Fd2, "#define __~s_H__\n\n", [Api#api.uname]),
	    put_chars(Fd2, H_defs),
	    io:format(Fd2, "#endif\n", []),
	    file:close(Fd2),
	    ok;
	error ->
	    error
    end.


output_start_link(Fd,Api) ->
    Chars =
	["start_link() ->\n",
	 "  start_link([]).\n\n",
	 "start_link(Opts) ->\n",
	 "  eapi_drv:start_link([\n",
	 "    {srv_name, ", Api#api.erl_srv_name, "},\n",
	 "    {prt_name, ", Api#api.erl_prt_name, "},\n",
	 "    {reg_name, ",  Api#api.erl_reg_name, "},\n",
	 "    {driver_name, ",  quote(Api#api.erl_driver_name), "},\n",
	 "    {app, ",  Api#api.erl_app_name, "} | Opts]).\n\n"],
    put_chars(Fd, Chars).

output_start(Fd,Api) ->
    Chars =
	["start() ->\n",
	 "  start([]).\n\n",
	 "start(Opts) ->\n",
	 "  eapi_drv:start([\n",
	 "    {srv_name, ", Api#api.erl_srv_name, "},\n",
	 "    {prt_name, ", Api#api.erl_prt_name, "},\n",
	 "    {reg_name, ",  Api#api.erl_reg_name, "},\n",
	 "    {driver_name, ",  quote(Api#api.erl_driver_name), "},\n",
	 "    {app, ",  Api#api.erl_app_name, "}|Opts]).\n\n"],
    put_chars(Fd, Chars).

output_stop(Fd,Api) ->
    Chars =
	["stop() ->\n",
	 "  eapi_drv:stop(", Api#api.erl_srv_name, ").\n\n"],
    put_chars(Fd, Chars).

quote(String) ->
    [$", String, $"].


put_chars(Fd, Chars) ->
    verify_chars(Chars),
    io:put_chars(Fd, Chars).

verify_chars(Chars) when is_list(Chars) ->
    verify_chars(Chars,[]);
verify_chars(Binary) when is_binary(Binary) ->
    reverse(binary_to_list(Binary));
verify_chars(Err) ->
    erlang:error({bad_char_list, Err}).

verify_chars([H|T], Buf) ->
    verify_chars(T, verify_chars(H, Buf));
verify_chars(X, Buf) when is_integer(X), X >= 0, X < 128 ->
    [X|Buf];
verify_chars(Binary,Buf) when is_binary(Binary) ->
    reverse(binary_to_list(Binary))++Buf;
verify_chars([], Buf) ->
    Buf;
verify_chars(Err, Buf) ->
    io:format("Error: bad character [~p] near ~s\n",
	      [Err, reverse(lists:sublist(Buf, 20))]),
    erlang:error({bad_char, Err}).
    

%% API description: list of
%% api ::= [decl*]
%%
%% decl ::=
%%  | {c_function_prefix, <string>} 
%%  | {c_symbol_prefix, <string>} 
%%  | {c_include, <string>}
%%
%%  | {erl_symbol_prefix, <string>}
%%  | {erl_include, <string>}
%%  | {erl_port_name, <string>}
%%  | {erl_srv_name, <string>}
%%  | {erl_reg_name, <string>}
%%  | {erl_driver_name, <string>}
%%  | {erl_default_interface, ['command'|'control']}
%%
%%  | {typedef, <type-name>,   <type>}
%%
%%  | {enum,[<enum-opts>,]<type-name>,<integer-type>,<enums>}
%%
%%  | {struct,[<struct-opts>,]<type-name>,<struct->fields}
%%
%%  | {function,[<function-opts>]<return-type>, <function-name>,
%%           [<function-arg>]}
%%
%%  type          = scalar-type | complex-type |  <constant> | void
%%  scalar-type   = boolean_t | <integer-type> | <float-type> |
%%                  atom_t | string_t | binary_t | pointer_t | object_t
%%                  {enum,<integer-type>,[{<enum-name>, <integer>}]}
%%
%%  complex-type =  {list,<type>}  | 
%%                  {array,<type>} | 
%%                  {tuple,[<type>]} |
%%                  {union,[<type>]}
%%
%%
%%  enums         = [{<enum-name>, <integer>|<atom>}]
%%  enum-name     = <atom>
%%  enum-opts     = [extern]
%%
%%  struct-fields  = [<struct-field>]
%%  struct-field   = {<type>,[,<field-opts>] <field-name>}
%%  struct-opts    = [extern]
%%  field-opts     = [{size,<field-name>}, {length,<filed-name>}]
%%
%%  function-opts  = [extern]
%%
%%  constant      = {const,<type>,<value>}
%%  unsigned-type = uint8_t | uint16_t | uint32_t | uint64_t | uint_t
%%  signed-type   = int8_t | int16_t | int32_t | int64_t | int_t | int
%%  integer-type  = unsigned-type | unsigned-type | size_t | ssize_t
%%  float-type    = float32_t | float64_t | float_t | float | double
%%  void          = {const,atom_t,ok}
%%  field-name    = atom_t
%%  function-name = atom_t
%%  type-name     = atom_t
%%  return-type   = <type>
%%  function-arg  = <type> | {arg,<type>,<arg-name>}
%%  
%%
%%  FIXME:
%%   encoding of object_t require command interface towards driver
%%   and TRM interface towards Erlang. 
%%   Add type enumeration of all pointer and object types
%%   where possible to add extra level of type check.
%%
%%
verify_file(File) ->
    case load(File) of
	{ok, _Api} ->
	    ok;
	{error,ErrList} ->
	    lists:foreach(
	      fun({Fmt,As}) ->
		      io:format("~s:"++Fmt++"\n", [File|As])
	      end, ErrList),
	    error
    end.


load(Filename, Outname) ->
    case load(Filename) of
	{ok, Api} ->
	    Name = filename:basename(Outname),
	    NAME = string:to_upper(Name),
	    {ok, Api#api { name = Name, uname = NAME }};
	{error,ErrList} ->
	    lists:foreach(
	      fun({Fmt,As}) ->
		      io:format("~s:"++Fmt++"\n", [Filename|As])
	      end, ErrList),
	    error
    end.


load(File) ->
    Ext = filename:extension(File),
    AppName = filename:basename(File, Ext), %% default app name
    case file:consult(File) of
	{ok,Items} ->
	    load_api(Items, #api { erl_app_name = AppName, 
				   types=dict:new(), 
				   functions=dict:new()} );
	{error, Reason} ->
	    {error, [{"error ~p", [Reason]}]}
    end.


load_api(Items, Api) ->
    load_api(Items, Api, []).

load_api([Item|Items], Api, ApiList) ->
    case Item of 
	{c_function_prefix, Prefix} ->
	    Api1 = Api#api { c_function_prefix = Prefix },
	    load_api(Items, Api1, ApiList);

	{c_symbol_prefix, Prefix} ->
	    Api1 = Api#api { c_symbol_prefix = Prefix },
	    load_api(Items, Api1, ApiList);

	{c_include, File} ->
	    Api1 = Api#api { c_includes = Api#api.c_includes ++ [File]},
	    load_api(Items, Api1, ApiList);

	{erl_function_prefix, Prefix} ->
	    Api1 = Api#api { erl_function_prefix = Prefix },
	    load_api(Items, Api1, ApiList);

	{erl_symbol_prefix, Prefix} ->
	    Api1 = Api#api { erl_symbol_prefix = Prefix },
	    load_api(Items, Api1, ApiList);

	{erl_include, File} ->
	    Api1 = Api#api { erl_includes = Api#api.erl_includes ++ [File]},
	    load_api(Items, Api1, ApiList);

	{erl_app_name, Name} ->
	    Api1 = Api#api { erl_app_name = Name },
	    load_api(Items, Api1, ApiList);

	{erl_srv_name, Name} ->
	    Api1 = Api#api { erl_srv_name = Name },
	    load_api(Items, Api1, ApiList);

	{erl_port_name, Name} ->
	    Api1 = Api#api { erl_prt_name = Name },
	    load_api(Items, Api1, ApiList);

	{erl_reg_name, Name} ->
	    Api1 = Api#api { erl_reg_name = Name },
	    load_api(Items, Api1, ApiList);

	{erl_driver_name, Name} ->
	    Api1 = Api#api { erl_driver_name = Name },
	    load_api(Items, Api1, ApiList);

	{erl_default_interface, Interface} when is_atom(Interface) ->
	    Api1 = Api#api { erl_default_interface = Interface },
	    load_api(Items, Api1, ApiList);

	{typedef, Name, Type} when is_atom(Name) ->
	    case dict:find(Name, Api#api.types) of
		error ->
		    case verify_type(Type,Api) of
			true ->
			    Types = dict:store(Name,Type,Api#api.types),
			    load_api(Items, Api#api { types = Types },
				     ApiList);
			false ->
			    Api1 = add_error("Bad type typedef ~s ~p",
					     [Name,Type], Api),
			    load_api(Items, Api1, ApiList)
		    end;
		{ok,_} ->
		    Api1 = add_error("Type ~s multiply defined", [Name],Api),
		    load_api(Items, Api1, ApiList)
	    end;

	{enum,Opts,Name,Encoding,Enums} 
	  when is_atom(Name), is_atom(Encoding), is_list(Enums) ->
	    Enum = #api_enum { name = atom_to_list(Name),
			       extern = proplists:get_bool(extern,Opts),
			       type   = Encoding,
			       enums  = Enums },
	    load_api_enum(Name, Enum, Items, Api, ApiList);

	{enum,Name,Encoding,Enums}
	    when is_atom(Name), is_atom(Encoding), is_list(Enums) ->
	    Enum = #api_enum { name  = atom_to_list(Name),
			       type  = Encoding,
			       enums = Enums },
	    load_api_enum(Name, Enum, Items, Api, ApiList);


	{struct,Name,Fields}  when is_atom(Name), is_list(Fields) ->
	    {ApiFields,Api1} = load_api_fields(Fields, Api),
	    Struct = #api_struct { name   = atom_to_list(Name),
				   fields = ApiFields },
	    load_api_struct(Name, Struct, Items, Api1, ApiList);

	{struct,Opts,Name,Fields}  
	  when is_atom(Name), is_list(Fields) ->
	    {ApiFields,Api1} = load_api_fields(Fields, Api),
	    Struct = #api_struct { name=atom_to_list(Name),
				   extern = proplists:get_bool(extern,Opts),
				   fields = ApiFields },
	    load_api_struct(Name, Struct, Items, Api1, ApiList);

	{function,Opts,Type,Name,Args} 
	  when is_list(Opts), is_atom(Name), is_list(Args) ->
	    {ApiArgs,Api1} = load_api_args(Args, Api),
	    Interface = case proplists:get_bool(command, Opts) of
			    true -> command;
			    false -> 
				case proplists:get_bool(control, Opts) of
				    true -> control;
				    false -> undefined
				end
			end,
	    Func = #api_function { name   = atom_to_list(Name),
				   type   = Type,
				   extern = proplists:get_bool(extern,Opts),
				   async  = proplists:get_bool(async,Opts),
				   interface = Interface,
				   args = ApiArgs },
	    load_api_function(Name, Func, Items, Api1, ApiList);

	{function,Type,Name,Args} 
	  when is_atom(Name), is_list(Args) ->
	    {ApiArgs,Api1} = load_api_args(Args, Api),
	    Func = #api_function { name = atom_to_list(Name),
				   type = Type,
				   args = ApiArgs },
	    load_api_function(Name, Func, Items, Api1, ApiList);
	_ ->
	    Api1 = add_error("item ~p not handled", [Item], Api),
	    load_api(Items, Api1, ApiList)
    end;
load_api([], Api, ApiList) when Api#api.error =:= [] ->
    %% Resolve names 
    SrvName = set_name(Api#api.erl_srv_name, Api#api.erl_app_name, "_srv"),
    PrtName = set_name(Api#api.erl_prt_name, Api#api.erl_app_name, "_prt"),
    RegName = set_name(Api#api.erl_reg_name, Api#api.erl_app_name, "_reg"),
    DrvName = set_name(Api#api.erl_driver_name, Api#api.erl_app_name, "_drv"),
    {ok, Api#api { items = reverse(ApiList),
		   erl_srv_name = SrvName,
		   erl_prt_name = PrtName,
		   erl_reg_name = RegName,
		   erl_driver_name = DrvName }};
load_api([], Api, _ApiList) ->
    {error, reverse(Api#api.error)}.


add_error(Fmt,Args,Api) -> 
    Api#api { error = [{Fmt,Args}|Api#api.error] }.


set_name("", Name, Suffix) -> Name ++ Suffix;
set_name(Name, _, _) -> Name.

%%
%% Add Enumerated type
%%
load_api_enum(ID, I, Items, Api, ApiList) ->
    case dict:find(ID, Api#api.types) of
	error ->
	    case verify_type(I, Api) of
		true ->
		    Types = dict:store(ID, I, Api#api.types),
		    Api1 = Api#api { types = Types },
		    load_api(Items, Api1, [{type,ID}|ApiList]);
		false ->
		    Api1 = add_error("Bad enum definition ~s ~p", 
				     [ID,{enum,I#api_enum.enums}],
				     Api),
		    load_api(Items, Api1, ApiList)
	    end;
	{ok,_} ->
	    Api1 = add_error("type ~s multiply defined", [ID], Api),
	    load_api(Items, Api1, ApiList)
    end.
    
%%
%% Add API struct/rectord
%%
load_api_struct(ID, I, Items, Api, ApiList) ->
    case dict:find(ID, Api#api.types) of
	error ->
	    %% Allow recursive type?
	    case verify_type(I,Api) of
		true ->
		    Types = dict:store(ID, I, Api#api.types),
		    Api1 = Api#api { types = Types },
		    load_api(Items, Api1, [{type,ID}|ApiList]);
		_ ->
		    Api1 = add_error("Bad type struct definition ~s ~p",
				     [ID,I#api_struct.fields], Api),
		    load_api(Items, Api1, ApiList)
	    end;
	{ok,_} ->
	    Api1 = add_error("struct ~s multiply defined", [ID], Api),
	    load_api(Items, Api1, ApiList)
    end.

%%
%% Add API function
%%
load_api_function(ID, I, Items, Api, ApiList) ->
    Api1 = check_return_type(I, Api),
    Api2 = check_arguments_type(I, Api1),
    case dict:find(ID, Api2#api.functions) of
	error ->
	    Index = Api2#api.index,
	    I1 = I#api_function { index = Index },
	    Funs = dict:store(ID,I1,Api2#api.functions),
	    Api3 = Api2#api { functions = Funs, index = Index+1 },
	    load_api(Items, Api3, [{function,ID}|ApiList]);
	{ok,_} ->
	    Api3 = add_error("function ~s multiply defined", 
			     [I#api_function.name],Api2),
	    load_api(Items, Api3, ApiList)
    end.

%% Check function return type.
%% For all structs in return type update encoder/decode status
check_return_type(F, Api) ->
    case verify_type(F#api_function.type, Api) of
	false ->
	    add_error("function ~s has bad return type: ~p", 
		      [F#api_function.name, F#api_function.type], Api);
	true ->
	    update_struct_info(F#api_function.type, Api,
			       fun(_Name, S, _Api) ->
				       S#api_struct { c_encode = true }
			       end)
    end.


%%
%%
%%
load_api_fields(Fields, Api) ->
    load_api_fields(Fields, [], Api).
    
load_api_fields([{Type,Name}|Fields], Fs, Api) ->
    Api1 = check_type(Type, Api),
    load_api_fields(Fields, [#api_field { name=Name, type=Type}|Fs], Api1);
load_api_fields([{Type,Opts,Name}|Fields], Fs, Api) 
  when is_list(Opts) ->
    Api1 = check_type(Type, Api),
    load_api_fields(Fields, [#api_field { name=Name, opts=Opts, type=Type}|Fs],
		    Api1);
load_api_fields([Fld|Fields], Fs, Api) ->
    Api1 = add_error("bad field declaration: ~p", [Fld],Api),
    load_api_fields(Fields, Fs, Api1);
load_api_fields([], Fs, Api) ->
    {reverse(Fs), Api}.

%%
%%
%%
load_api_args(Args, Api) ->
    load_api_args(Args, [], Api).
    
load_api_args([{Type,Name}|Fields], As, Api) ->
    Api1 = check_type(Type, Api),
    load_api_args(Fields, [#api_arg { name=Name, type=Type}|As], Api1);
load_api_args([{Type,Opts,Name}|Args], As, Api) 
  when is_list(Opts) ->
    Api1 = check_type(Type, Api),
    load_api_args(Args, [#api_arg { name=Name, opts=Opts, type=Type}|As],
		  Api1);
load_api_args([Arg|Args], As, Api) ->
    Api1 = add_error("bad argument declaration: ~p", [Arg], Api),
    load_api_args(Args, As, Api1);    
load_api_args([], As, Api) ->
    {reverse(As), Api}.

%% Check argument list types
check_arguments_type(I, Api) ->
    check_args_type(I#api_function.args, Api).

check_args_type([A|Args], Api) ->
    Api1 = check_arg_type(A#api_arg.name, A#api_arg.type, Api),
    check_args_type(Args, Api1);
check_args_type([], Api) ->
    Api.

%% Check an argument type
check_arg_type(ArgName, Type, Api) ->
    case verify_type(Type, Api) of
	false ->
	    add_error("function argument ~s has bad type: ~p", 
		      [ArgName, Type], Api);
	true ->
	    update_struct_info(Type, Api,
			       fun(_Name, S, _Api) ->
				       S#api_struct { c_decode = true,
						      erl_encode = true }
			       end)
    end.

update_struct_info(Type, Api, Fun) ->
    case Type of
	{list,T}    -> update_struct_info(T,Api,Fun);
	{array,T}   -> update_struct_info(T,Api,Fun);
	{const,T,_} -> update_struct_info(T,Api,Fun);
	{tuple,Ts} ->
	    foldl(fun(T,Api1) -> 
			  update_struct_info(T,Api1,Fun)
		  end, Api, Ts);
	{union,Ts} ->
	    foldl(fun(T,Api1) -> 
			  update_struct_info(T,Api1,Fun)
		  end, Api, Ts);
	#api_struct { fields = Fs } ->
	    foldl(fun(F,Api1) -> 
			  update_struct_info(F#api_field.type,Api1,Fun)
		  end, Api, Fs);
	#api_enum {} -> Api;

	Name when is_atom(Name) ->
	    case dict:find(Name, Api#api.types) of
		{ok,S = #api_struct {}} ->
		    %% update fields first
		    Api1 = update_struct_info(S,Api,Fun),
		    S1 = Fun(Name,S,Api1),
		    Api1#api { types=dict:store(Name, S1, Api1#api.types) };
		{ok,T} ->
		    update_struct_info(T, Api, Fun);
		error ->
		    Api
	    end
    end.

    


%% Check that type exists
check_type(Type, Api) ->
    case verify_type(Type, Api) of
	false ->
	    add_error("bad type: ~p", [Type], Api);
	true ->
	    Api
    end.


    
verify_type(Type, Api) ->
    case Type of
	boolean_t -> true;
	uint_t    -> true;
	uint8_t   -> true;
	uint16_t  -> true;
	uint32_t  -> true;
	uint64_t  -> true;
	int       -> true;
	int_t     -> true;
	int8_t    -> true;
	int16_t   -> true;
	int32_t   -> true;
	int64_t   -> true;
	float32_t -> true;
	float64_t -> true;
	float_t   -> true;
	size_t    -> true;
	ssize_t   -> true;
	binary_t  -> true;
	object_t  -> true;
	atom_t    -> true;
	string_t  -> true;
	pointer_t -> true;

	#api_enum { type=Encoding, enums=Enums} ->
	    Values = map(fun({_,Value}) -> Value end, Enums),
	    Names  = map(fun({Name,_}) -> Name end, Enums),
	    verify_type(Encoding,Api)
		andalso
		is_integer_type(Encoding,Api) 
		andalso 
		lists:all(fun(Value) -> 
				  is_atom(Value) orelse is_integer(Value)
			  end, Values)
		andalso
		lists:all(fun(Name) -> is_atom(Name) end, Names) 
		andalso
		(length(Names) == length(lists:usort(Names)))
		andalso
		lists:all(fun(Value) ->
				  if is_atom(Value) -> 
					  true;
				     true ->
					  verify_type({const,Encoding,Value},
						      Api)
				  end
			  end, Values);
	#api_struct { fields = Fields } when is_list(Fields) ->
	    FieldNames = lists:map(fun(F) -> F#api_field.name end, Fields),
	    length(FieldNames) == length(lists:usort(FieldNames));

	{list,EType} -> 
	    verify_type(EType,Api);
	{array,EType} ->
	    verify_type(EType,Api);
	{tuple,Types} when is_list(Types) ->
	    lists:all(fun(T) -> verify_type(T, Api) end, Types);
	{union, Types} ->
	    lists:all(fun(UType)  -> verify_type(UType, Api) end, 
		      Types);
	{const,CType,Value} ->
	    verify_type(CType,Api) 
		andalso
		verify_value(CType, Value, Api);
	Name when is_atom(Name) ->
	    case dict:find(Name, Api#api.types) of
		{ok,NType} ->
		    verify_type(NType, Api);
		error ->
		    false
	    end;
	_ ->
	    false
    end.

verify_value(T, V, Api) ->
    case T of
	uint8_t -> 
	    is_integer(V) andalso (V>=0) andalso (V =< 16#ff);
	uint16_t ->
	    is_integer(V) andalso (V>=0) andalso (V =< 16#ffff);
	uint32_t ->
	    is_integer(V) andalso (V>=0) andalso (V =< 16#ffffffff);
	uint64_t ->
	    is_integer(V) andalso (V>=0) andalso (V =< 16#ffffffffffffffff);
	uint_t -> is_integer(V) andalso (V>=0);
	size_t -> is_integer(V) andalso (V>=0);
	int8_t -> 
	    is_integer(V) andalso (V >= -16#80) andalso (V =< 16#7f);
	int16_t ->
	    is_integer(V) andalso (V >= -16#8000) andalso (V =< 16#7fff);
	int32_t ->
	    is_integer(V) andalso (V >= -16#80000000) 
		andalso (V =< 16#7fffffff);
	int64_t ->
	    is_integer(V) andalso (V >= -16#8000000000000000) 
		andalso (V =< 16#7fffffffffffffff);
	int_t  -> is_integer(V);
	int    -> is_integer(V);
	ssize_t  ->
	    is_integer(V);
	float32_t ->
	    is_float(V);
	float64_t ->
	    is_float(V);
	float_t ->
	    is_float(V);
	atom_t ->
	    is_atom(V);
	string_t -> 
	    is_string(V);
	binary_t -> 
	    is_binary(V);
	object_t -> 
	    is_binary(V);

	{list,EType} -> 
	    is_list(V) andalso
		lists:all(
		  fun(Elem) ->
			  verify_value(EType, Elem, Api) 
		  end, V);
	{array,EType} ->
	    is_tuple(V) andalso
		lists:all(
		  fun(Elem) -> 
			  verify_value(EType, Elem, Api) 
		  end, tuple_to_list(V));
	{tuple,Types} ->
	    is_list(Types)
		andalso 
		is_tuple(V) 
		andalso
		lists:all(
		  fun({Ti,Vi}) ->
			  verify_value(Ti,Vi,Api)
		  end,
		  lists:zip(Types, tuple_to_list(V)));

	{union,Types} ->
	    lists:any(
	      fun(Ti) -> verify_value(Ti, V, Api) end,
	      Types);

	#api_enum { type=Encoding, enums=Enums } ->
	    if is_atom(V) ->
		    case lists:keysearch(V, 1, Enums) of
			false -> false;
			{value,_} -> true
		    end;
	       is_integer(V) ->
		    verify_value(Encoding,V,Api)
	    end;

	#api_struct { name=Name, fields=Fields} ->
	    is_tuple(V)
		andalso 
		(size(V) == length(Fields)+1)
		andalso
		(element(1,V) == Name) 
		andalso
		lists:all(
		  fun({F,FV}) ->
			  verify_value(F#api_field.type,FV,Api)
		  end, lists:zip(Fields, tl(tuple_to_list(V))));


	Name when is_atom(Name) ->
	    case dict:find(Name, Api#api.types) of
		{ok,NType} ->
		    verify_value(NType, V, Api);
		error ->
		    false
	    end;
	_ ->
	    false
    end.


is_string([X|Xs]) when X >= 0, X =< 255 -> is_string(Xs);
is_string([]) -> true;
is_string(_) -> false.

is_integer_type(Type, Api) ->
    case Type of
	uint8_t -> true;
	uint16_t -> true;
	uint32_t -> true;
	uint64_t -> true;
	uint_t -> true;
	int8_t -> true;
	int16_t -> true;
	int32_t -> true;
	int64_t -> true;
	int_t -> true;
	int   -> true;
	size_t -> true;
	ssize_t -> true;
	Name when is_atom(Name) ->
	    case dict:find(Name, Api#api.types) of
		error -> false;
		{ok,Type1} -> is_integer_type(Type1,Api)
	    end;
	_ -> false
    end.

is_pointer_type(Type, Api) ->
    case Type of
	{list, _EType} -> true;
	{tuple, _Types} -> true;
	{const, CType,_} -> is_pointer_type(CType,Api);
	{array, _AType} -> true;
	pointer_t -> true;
	#api_struct{} -> true; %% ???
	TName when is_atom(TName) ->
	    is_pointer_type(dict:fetch(TName,Api#api.types), Api);
	_ -> false
    end.

%%
%% Resolve a type into base types
%%
%%
%% Resolve a type
%%
resolve_type(Type, Api) ->
    case Type of
	boolean_t -> Type;
	uint8_t -> Type;
	uint16_t -> Type;
	uint32_t -> Type;
	uint64_t -> Type;
	uint_t -> Type;
	int8_t -> Type;
	int16_t -> Type;
	int32_t -> Type;
	int64_t -> Type;
	int_t -> Type;
	int   -> Type;
	float32_t -> Type;
	float64_t -> Type;
	float_t -> Type;
	size_t -> Type;
	ssize_t -> Type;
	pointer_t -> Type;
	binary_t -> Type;
	object_t -> Type;
	atom_t -> Type;
	string_t -> Type;

	{list,EType} ->
	    {list,resolve_type(EType,Api)};
	{array,EType} ->
	    {array,resolve_type(EType,Api)};
	{tuple,Types} ->
	    {tuple,map(fun(EType) -> resolve_type(EType,Api) end, 
		       Types)};
	{union,Types} ->
	    {union, map(fun(T) -> resolve_type(T,Api) end, Types)};
	{const,T,CV} ->
	    {const,resolve_type(T,Api), CV};

	#api_enum { type=T } ->
	    Type#api_enum { type=resolve_type(T,Api) };
	#api_struct { fields=Fields } ->
	    Fs = map(fun(F) ->
			     T = resolve_type(F#api_field.type,Api),
			     F#api_field {type=T}
		     end, Fields),
	    Type#api_struct { fields = Fs};

	Name when is_atom(Name) ->
	    resolve_type(dict:fetch(Name,Api#api.types), Api)
    end.
				
